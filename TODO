CLI

* Accept multiple interfaces when adding or deleting static MACs
* Group identical static MACs in a single command when building config
* Timeout in "Password:" prompt
* Ask for saving configuration on "reload"

MLS

* When we have static multicast macs, forward matching packets to
  all appropriate ports, not just the first

BUG FIXING
1) Completion comanda de configurare interface ...
2) no interface ... mumu
3) show run / start nu arata interfetele != eth, vlan

Campurile de tip char[] cu lungime cunoscuta trebuie re-verificate, pentru a stabili
(si a fi consecventi) una din urmatoarele reguli:
* declaram campurile avand dimensiune exact cat constanta (ex. IFNAMSIZ) si folosim
  intotdeauna strncpy cu constanta; string-ul NU este null terminated daca are exact
  lungimea din constanta -> aici pot sa apara probleme pentru ca atunci cand se
  "citeste" (adica se copiaza intr-un alt buffer "suficient de mare") string-ul
  rezultat nu va fi de asemenea null-terminated
* declaram campurile avand dimensiune constanta + 1, folosim strncpy pentru scriere
  in ele (si punem '\0' in str[CONSTANTA] pentru a ne asigura ca e null-terminated);
  folosim strcpy pentru citire (pentru ca este null terminated)

Shared (shared.c)
Trebuie asigurata consistenta intre comenzile de tipul cfg_ in sensul apelarii lor
avand lock pe cfg sau nu: ori fiecare functie isi asigura singura zona critica
(cfg_lock() si cfg_unlock()), ori trebuie asigurat din afara pentru toate. Hit:
cfg_lock() poate fi apelat de mai multe ori, fara probleme. Mai bine se face din
interior la fiecare => e mai sigur si mai usor de programat. Logic ar fi ca doar
functiile (statice) cu __ la inceput sa functioneze cu zona critica asigurata din
exterior.

Comanda write mem nu merge in cazul in care nu exista /etc/lisa si/sau /etc/lisa/tags.
Normal de altfel, pt ca fopen intoarce eroare. Ar trebui totusi ca functia sa creeze
directoarele in cazul in care nu exista.

./swcfgload <if_name> <tag_name> [<description>] - Nu adauga si tag-ul (cel putin
asa se intelege din output-ul lui show run).


BUG FIX build userspace

1) flagul "-g" e pus dupa principii "random"; ar trebui sa se faca in toate Makefile
o regula de genul "daca e definit DEBUG, atunci CFLAGS+= -g; se compileaza cu DEBUG=1 make
pentru debugging

2) daca se fac modificari in mm.c si se da make (general, in userspace), nu se recompileaza
nimic; ar trebui buildate intai chestiile din lib, apoi restul sa aiba dependente


--- BUG#? ---
"mac-address-table static ..." not compatible with interface names

The "mac-address-table static ..." is no longer compatible with the interface
naming convention. The syntax/parser_config needs to be adjusted to accept an
arbitrary name for the interface (maybe except for LiSA's own vlanX?), just
like the "interface ..." command.

--- BUG#? ---
Tagged frames can exceed standard Ethernet mtu of 1500

It is usual for untagged interfaces to receive frames of exactly 1500 (Ethernet
maximum mtu) bytes data. However, when sent out on a tagged interface, these
frames will be 1504 long and therefore will exceed the maximum Ethernet mtu.

When setting interfaces to "switchport mode trunk", LiSA should automagically
set the mtu to 1504 on the device to avoid trouble. Unfortunately, many
devices don't support "Jumbo Frames" (frames larger than standard Ethernet) in
hardware and issue an error on set_mtu() if mtu is larger than 1500. In such
case, LiSA should issue a warning when setting the port to trunk mode and
perhaps advise the user to change all untagged interfaces mtu to 1496.

Case study: Broadcom Tg3 driver (drivers/net/tg3.c)

...

#define TG3_MAX_MTU(tp) \
    ((tp->tg3_flags2 & TG3_FLG2_JUMBO_CAPABLE) ? 9000 : 1500)

...

static int tg3_change_mtu(struct net_device *dev, int new_mtu)
{
    struct tg3 *tp = netdev_priv(dev);
    int err;

    if (new_mtu < TG3_MIN_MTU || new_mtu > TG3_MAX_MTU(tp))
        return -EINVAL;

...

